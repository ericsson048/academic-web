"""
Django management command to clear sample data from the database.

This command removes all sample data generated by the seed_data command
without affecting the database schema. It provides a confirmation prompt
to prevent accidental data deletion.

Usage:
    python manage.py clear_sample_data
    python manage.py clear_sample_data --no-input  # Skip confirmation
"""
from django.core.management.base import BaseCommand
from django.db import transaction
from django.contrib.auth import get_user_model
from students.models import Class, Student, Subject, Semester
from grades.models import Grade, GradeHistory
from analytics.models import PerformanceIndicator

User = get_user_model()


class Command(BaseCommand):
    help = 'Clear all sample data from the database without affecting schema'
    
    def add_arguments(self, parser):
        parser.add_argument(
            '--no-input',
            action='store_true',
            help='Skip confirmation prompt and clear data immediately'
        )
        parser.add_argument(
            '--keep-users',
            action='store_true',
            help='Keep user accounts (only delete academic data)'
        )
    
    def handle(self, *args, **options):
        """Main command handler."""
        no_input = options['no_input']
        keep_users = options['keep_users']
        
        # Show what will be deleted
        self._show_data_summary()
        
        # Confirmation prompt
        if not no_input:
            self.stdout.write('\n' + '=' * 60)
            self.stdout.write(self.style.WARNING('⚠ WARNING: This will delete all data shown above!'))
            self.stdout.write('=' * 60)
            
            confirm = input('\nAre you sure you want to continue? Type "yes" to confirm: ')
            
            if confirm.lower() != 'yes':
                self.stdout.write(self.style.ERROR('✗ Operation cancelled'))
                return
        
        # Clear data
        self.stdout.write('\n' + self.style.SUCCESS('Starting data clearing...'))
        
        try:
            with transaction.atomic():
                deleted_counts = self._clear_data(keep_users)
            
            self.stdout.write(self.style.SUCCESS('\n✓ Data clearing completed successfully!'))
            self._print_deletion_summary(deleted_counts)
            
        except Exception as e:
            self.stdout.write(self.style.ERROR(f'✗ Error during clearing: {str(e)}'))
            raise
    
    def _show_data_summary(self):
        """Display summary of data that will be deleted."""
        self.stdout.write('\n' + '=' * 60)
        self.stdout.write(self.style.WARNING('DATA TO BE DELETED'))
        self.stdout.write('=' * 60)
        
        # Count records
        performance_count = PerformanceIndicator.objects.count()
        grade_history_count = GradeHistory.objects.count()
        grade_count = Grade.objects.count()
        student_count = Student.objects.count()
        semester_count = Semester.objects.count()
        subject_count = Subject.objects.count()
        class_count = Class.objects.count()
        user_count = User.objects.count()
        
        self.stdout.write(f'Performance Indicators: {performance_count}')
        self.stdout.write(f'Grade History Records:  {grade_history_count}')
        self.stdout.write(f'Grades:                 {grade_count}')
        self.stdout.write(f'Students:               {student_count}')
        self.stdout.write(f'Semesters:              {semester_count}')
        self.stdout.write(f'Subjects:               {subject_count}')
        self.stdout.write(f'Classes:                {class_count}')
        self.stdout.write(f'Users:                  {user_count}')
        self.stdout.write('=' * 60)
    
    def _clear_data(self, keep_users):
        """Clear all sample data in the correct order to respect foreign keys."""
        deleted_counts = {}
        
        # Delete in order to respect foreign key constraints
        # Start with dependent tables first
        
        self.stdout.write('Deleting performance indicators...')
        count, _ = PerformanceIndicator.objects.all().delete()
        deleted_counts['performance_indicators'] = count
        self.stdout.write(f'  ✓ Deleted {count} performance indicators')
        
        self.stdout.write('Deleting grade history...')
        count, _ = GradeHistory.objects.all().delete()
        deleted_counts['grade_history'] = count
        self.stdout.write(f'  ✓ Deleted {count} grade history records')
        
        self.stdout.write('Deleting grades...')
        count, _ = Grade.objects.all().delete()
        deleted_counts['grades'] = count
        self.stdout.write(f'  ✓ Deleted {count} grades')
        
        self.stdout.write('Deleting students...')
        count, _ = Student.objects.all().delete()
        deleted_counts['students'] = count
        self.stdout.write(f'  ✓ Deleted {count} students')
        
        self.stdout.write('Deleting semesters...')
        count, _ = Semester.objects.all().delete()
        deleted_counts['semesters'] = count
        self.stdout.write(f'  ✓ Deleted {count} semesters')
        
        self.stdout.write('Deleting subjects...')
        count, _ = Subject.objects.all().delete()
        deleted_counts['subjects'] = count
        self.stdout.write(f'  ✓ Deleted {count} subjects')
        
        self.stdout.write('Deleting classes...')
        count, _ = Class.objects.all().delete()
        deleted_counts['classes'] = count
        self.stdout.write(f'  ✓ Deleted {count} classes')
        
        if not keep_users:
            self.stdout.write('Deleting users...')
            count, _ = User.objects.all().delete()
            deleted_counts['users'] = count
            self.stdout.write(f'  ✓ Deleted {count} users')
        else:
            deleted_counts['users'] = 0
            self.stdout.write('  ℹ Keeping user accounts (--keep-users flag)')
        
        return deleted_counts
    
    def _print_deletion_summary(self, deleted_counts):
        """Print summary of deleted data."""
        self.stdout.write('\n' + '=' * 60)
        self.stdout.write(self.style.SUCCESS('DELETION SUMMARY'))
        self.stdout.write('=' * 60)
        self.stdout.write(f"Performance Indicators: {deleted_counts['performance_indicators']}")
        self.stdout.write(f"Grade History Records:  {deleted_counts['grade_history']}")
        self.stdout.write(f"Grades:                 {deleted_counts['grades']}")
        self.stdout.write(f"Students:               {deleted_counts['students']}")
        self.stdout.write(f"Semesters:              {deleted_counts['semesters']}")
        self.stdout.write(f"Subjects:               {deleted_counts['subjects']}")
        self.stdout.write(f"Classes:                {deleted_counts['classes']}")
        self.stdout.write(f"Users:                  {deleted_counts['users']}")
        self.stdout.write('=' * 60)
        self.stdout.write('\nDatabase is now empty and ready for new data.')
        self.stdout.write('Schema remains intact - you can run seed_data again.\n')
